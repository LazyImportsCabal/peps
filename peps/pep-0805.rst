PEP: 805
Title: Explicit lazy imports
Author: Pablo Galindo <pablogsal@python.org>,
        Germán Méndez Bravo <german.mb@gmail.com>,
        Thomas Wouters <thomas@python.org>,
        Dino Viehland <dinoviehland@gmail.com>,
        Brittany Reynoso <brittanyrey@gmail.com>,
        Noah Kim <noahbkim@gmail.com>,
        Tim Stumbaugh <me@tjstum.com>
Discussions-To: Pending
Status: Draft
Type: Standards Track
Topic: Release
Created: 22-09-2025
Python-Version: 3.15


Abstract
========

This PEP introduces lazy imports as an explicit language feature. Lazy imports
defer the loading and execution of a module until the first time the imported
name is used, rather than at the point of the import statement.

By allowing developers to mark individual imports as lazy with explicit syntax, Python programs
can reduce startup time, memory usage, and unnecessary work. This is
particularly beneficial for command-line tools, test suites, and applications
with large dependency graphs.

The proposal preserves full backwards compatibility: normal import statements
remain unchanged, and lazy imports are enabled only where explicitly requested.

Motivation
==========

A common convention in Python code is to place all imports at the module
level, typically at the beginning of the file. This avoids repetition, makes dependencies clear
and minimizes runtime overhead by only evaluating an import statement once
per module. A major drawback with this approach is that importing the first
module for an execution of Python (the "main" module) often triggers an immediate
cascade of imports, loading many dependencies that may never be used. The effect
is especially costly for command-line tools with multiple subcommands, where
even running the command with ``--help`` can load dozens of unnecessary modules and
take several seconds, just to get feedback to the user of how to run the program at
all. Then the user incurs all that overhead again when they figure out the command
they want and invoke the program "for real."

A somewhat common response is to delay imports by moving them into functions
(inline imports), but this practice is very manual to implement and maintain.
Additionally, it obfuscates the full set of dependencies for a module.

The standard library provides ``importlib.util.LazyLoader`` to solve some of these
problems. It permits imports at the module level to work *mostly* like inline
imports do. Scientific Python libraries have adopted a similar pattern, formalized
in `SPEC 1 <https://scientific-python.org/specs/spec-0001/>`_. There's also the
third-party `lazy_loader <https://pypi.org/project/lazy-loader/>`_ package.
Imports used solely for static type checking are another source of potentially unneeded
imports, and there are similarly disparate approaches to minimizing the overhead.

These approaches don't cover all cases, add runtime overhead in unexpected
places, are non-obvious, and non-standardized. This proposal introduces
lazy imports syntax with a design that is local, explicit, controlled, and
granular. Each of these qualities is essential to making the feature
predictable and safe to use in practice.

The behavior is **local**: laziness applies only to the specific import marked
with the ``lazy`` keyword, and it does not cascade recursively into other
imports. This ensures that developers can reason about the effect of laziness
by looking only at the line of code in front of them, without worrying about
whether imported modules will themselves behave differently. A ``lazy import``
is an isolated decision in a single module, not a global shift in semantics.

The semantics are **explicit**. When a name is imported lazily, the binding
is created in the importing module immediately, but the target module is not
loaded until the first time the name is accessed. After this point, the binding
is indistinguishable from one created by a normal import. This clarity reduces
surprises and makes the feature accessible to developers who may not be
deeply familiar with Python’s import machinery.

Lazy imports are **controlled**, in the sense that deferred loading is only
triggered by the importing code itself. In the general case, a library will only
experience lazy imports if its own authors choose to mark them as such. This
avoids shifting responsibility onto downstream users and prevents accidental
surprises in library behavior. Since library authors typically manage their own
import subgraphs, they retain predictable control over when and how laziness is
applied.

The mechanism is also **granular**. It is introduced through explicit syntax on
individual imports, rather than a global flag or implicit setting. This allows
developers to adopt it incrementally, starting with the most
performance-sensitive areas of a codebase. As this feature is introduced to the 
community, we want to make the experience of onboarding optional, progressive, and
adaptable to the needs of each project.

In addition to the new lazy import syntax, we *also* propose a way to
control lazy imports at the application level: globally disabling or
enabling, and selectively disabling. These are provided for debugging,
testing and experimentation, and are not expected to be the common way to
control lazy imports.

The design of lazy imports provides several concrete advantages:

* Command-line tools are often invoked directly by a user, so latency — in particular
  startup latency — is quite noticeable. These programs are also typically
  short-lived processes (contrasted with, e.g., a web server). Most conventions
  would have a CLI with multiple subcommands import every dependency up front,
  even if the user only requests ``tool --help`` (or ``tool subcommand --help``).
  With lazy imports, only the code paths actually reached will import a module.
  This can reduce startup time by 50–70% in practice, providing a visceral improvement
  to a common user experience and improving Python's competitiveness in domains
  where fast startup matters most.

* Type annotations frequently require imports that are never used at runtime.
  The common workaround is to wrap them in ``if TYPE_CHECKING:`` blocks [#f1]_.
  With lazy imports, annotation-only imports impose no runtime penalty, eliminating
  the need for such guards and making annotated codebases cleaner.

* Large applications often import thousands of modules, and each module creates
  function and type objects, incurring memory costs. In long-lived processes,
  this noticeably raises baseline memory usage. Lazy imports defer these costs
  until a module is needed, keeping unused subsystems unloaded. Memory savings of
  30–40% have been observed in real workloads.

Rationale
=========

The design of this proposal is centered on clarity, predictability, and ease of
adoption. Each decision was made to ensure that lazy imports provide tangible
benefits without introducing unnecessary complexity into the language or its
runtime.

It is also worth noting that while this PEP outlines one specific approach, we
list alternate implementation strategies for some of the core aspects and
semantics of the proposal. If the community expresses a strong preference for a
different technical path that still preserves the same core semantics or there
is fundamental disagreement over the specific option, we have included the
brainstorming we have already completed in preparation for this proposal as reference.

The choice to introduce a new ``lazy`` keyword reflects the need for explicit
syntax. Import behavior is too fundamental to be left implicit or hidden behind
global flags or environment variables. By marking laziness directly at the
import site, the intent is immediately visible to both readers and tools. This
avoids surprises, reduces the cognitive burden of reasoning about imports, and
keeps the semantics in line with Python's tradition of explicitness.

Another important decision is to represent lazy imports with proxy objects in
the module's namespace, rather than by modifying dictionary lookup. Earlier
approaches experimented with embedding laziness into dictionaries, but this
blurred abstractions and risked affecting unrelated parts of the runtime. The
proxy approach is simpler: it behaves like a placeholder until first use, at
which point it resolves the import and rebinds the name. From then on, the
binding is indistinguishable from a normal import. This makes the mechanism
easy to explain and keeps the rest of the interpreter unchanged.

Compatibility for library authors was also a key concern. Many maintainers need
a migration path that allows them to support both new and old versions of
Python at once. For this reason, the proposal includes the ``__lazy_modules__``
global as a transitional mechanism. A module can declare which imports should
be treated as lazy, and on Python 3.15 or later those imports will become lazy
automatically. On earlier versions the declaration is ignored, leaving imports
eager. This gives authors a practical bridge until they can rely on the keyword
as the canonical syntax.

Finally, the feature is designed to be adopted incrementally. Nothing changes
unless a developer explicitly opts in, and adoption can begin with just a few
imports in performance-sensitive areas. This mirrors the experience of gradual
typing in Python: a mechanism that can be introduced progressively, without
forcing projects to commit globally from day one. Notably, the adoption can also
be done from the "outside in," permitting CLI authors to introduce lazy imports
and speed up user-facing tools, without requiring changes to every library the
tool might use.

By combining explicit syntax, a simple runtime model, a compatibility layer,
and gradual adoption, this proposal balances performance improvements with the
clarity and stability that Python users expect.


Other design decisions
----------------------

* The scope of laziness is deliberately local and non-recursive. A lazy import
  only affects the specific statement where it appears; it does not cascade into
  other modules or submodules. This choice is crucial for predictability. When
  developers read code, they can reason about import behavior line by line,
  without worrying about hidden laziness deeper in the dependency graph. The
  result is a feature that is powerful but still easy to understand in context.

* In addition, it is useful to provide a mechanism to activate or deactivate lazy
  imports at a global level. While the primary design centers on explicit syntax,
  there are scenarios—such as large applications, testing environments, or
  frameworks—where enabling laziness consistently across many modules provides
  the most benefit. A global switch makes it easy to experiment with or enforce
  consistent behavior, while still working in combination with the filtering API
  to respect exclusions or tool-specific configuration. This ensures that global
  adoption can be practical without reducing flexibility or control.


Specification
=============

A new soft keyword is added, ``lazy`` (other names have been suggested), which
can appear in front of both forms of import:

* ``lazy import spam``

* ``lazy from spam import ham``

The soft keyword is only allowed at the global (module) level, **not** inside
functions. It's also not allowed in try blocks. Import statements that use
the soft keyword are *potentially lazy*. In addition, star imports will not 
be supported for lazy import semantics by the soft keyword and will instead
raise a syntax error.

A module may contain a ``__lazy_modules__`` attribute, which is a list of
names of imports to make *potentially lazy* (as if the ``lazy`` keyword was
used). This name is checked on each ``import`` statement.

The normal (non-lazy) import statement will check the global lazy imports
flag. If it is ``"enabled"``, all imports at the global level of all modules —
except statements in a ``try`` block — are *potentially lazy*.

If the global lazy imports flag is set to ``"disabled"``, no *potentially lazy*
import is ever imported lazily, and the behavior is equivalent to a regular
``import`` statement: the import is *eager* (as if the lazy keyword was not used).

For *potentially lazy* imports, the lazy imports filter (if set) is called,
passing the name of the module doing the import, the name of the module being
imported, and (if applicable) the fromlist. If the lazy import filter returns
``True``, the *potentially lazy* import becomes a lazy import. Otherwise, the
import is *not* lazy, and the normal (eager) import continues.

When an import is lazy, ``__lazy_import__`` is called instead of
``__import__``. ``__lazy_import__`` has the same function signature as
``__import__``. It adds the module to ``sys.lazy_modules``, a set of modules
which have been lazily imported, and returns a "lazy module object".

The implementation of ``from ... import`` (the ``IMPORT_FROM`` bytecode
implementation) checks if the module it's fetching from is a lazy module
object, and if so, returns a lazy object for each name instead.

The end result of this process is that lazy imports (regardless of how they
are enabled) result in lazy objects being assigned to global variables.

Lazy module objects do not appear in ``sys.modules``, just the
``sys.lazy_modules`` set. Lazy objects should only end up stored in global
variables, and the common ways to access those variables (regular variable
access, module attributes) will resolve lazy imports ("reify") and replace
them when they're accessed.

It is still possible to expose lazy objects through other means, like
debuggers. This is not considered a problem.

Reification
-----------

When a lazy object is first used, it needs to be reified. This means
resolving the import at that point in the program, and replacing the lazy
object with the concrete one. Reification imports the module in the same way
as it would have been if it had been imported eagerly, barring intervening
changes to the import system (e.g. to ``sys.path``, ``sys.meta_path``,
``sys.path_hooks`` or ``__import__``).

Reification still calls ``__import__`` to resolve the import. Once the module is
reified, it's removed from ``sys.lazy_modules``.

Reification does **not** automatically occur when a module that was previously lazily
imported is subsequently eagerly imported. Reification also does **not** immediately
resolve all lazy objects (e.g. ``lazy from`` statements) that referenced the module.
It **only** resolves the lazy object being accessed.

Accessing a lazy object (from a global variable or a module attribute)
reifies the object. Accessing a module's ``__dict__`` reifies **all** lazy objects
in that module.

More indirect ways of accessing arbitrary globals (e.g. inspecting
``frame.f_globals``) do **not** reify all the objects. A lazy object can be
resolved explicitly by calling the ``get`` method.


Backwards Compatibility
=======================

Lazy imports are **opt-in**. Existing programs continue to run unchanged unless
a project explicitly enables laziness (via ``lazy`` syntax, ``__lazy_modules__``,
or an interpreter-wide switch).

Unchanged semantics
-------------------

* Regular ``import`` and ``from ... import ...`` remain eager unless explicitly
  made *potentially lazy* by the local or global mechanisms provided.
* Dynamic import APIs remain eager and unchanged: ``__import__()`` and
  ``importlib.import_module()``.
* Import hooks and loaders continue to run under the standard import protocol
  when a lazy binding is first used.

Observable behavioral shifts (opt-in only)
------------------------------------------

These changes are limited to bindings explicitly made lazy:

* **Error timing.** Exceptions that would have occurred during an eager import
  (for example ``ImportError`` or ``AttributeError`` for a missing member) now
  occur at the first *use* of the lazy name.
* **Side-effect timing.** Import-time side effects in lazily imported modules
  occur at first use of the binding, not at module import time.
* **Import order.** Because modules are imported on first use, the order in
  which modules are imported may change.
* **Presence in ``sys.modules``.** A lazily imported module may not appear in
  ``sys.modules`` until first use. After reification, it must appear in
  ``sys.modules``. If some other code eagerly imports the same module before
  first use, the lazy binding resolves to that existing module object when
  it is first used.
* **Proxy visibility.** Before first use, the bound name refers to a lazy proxy.
  Indirect introspection that touches the value may observe a proxy lazy object
  representation. After first use, the name is rebound to the real object and
  becomes indistinguishable from an eager import.

Thread-safety and reification
-----------------------------

First use of a lazy binding follows the existing import-lock discipline. Exactly
one thread performs the import and **atomically rebinds** the importing module's
global to the resolved object. Concurrent readers thereafter observe the real
object.

Typing and tools
----------------

Type checkers and static analyzers may treat ``lazy`` imports as ordinary
imports for name resolution. At runtime, annotation-only imports can be marked
``lazy`` to avoid startup overhead. IDEs and debuggers should be prepared to
display lazy proxies before first use and the real objects thereafter.


Security Implications
=====================

There are no known security vulnerabilities introduced by lazy imports.

How to Teach This
=================

The new ``lazy`` keyword will be documented as part of the language standard. 

As this feature is opt-in, new Python users should be able to continue using the 
language as they are used to. For experienced developers, we expect them to leverage
lazy imports for the variety of benefits listed above (decreased latency, decreased
memory usage, etc) on a case-by-case basis. Developers interested in the performance
of their Python binary will likely leverage profiling to understand the import time 
overhead in their codebase and mark the necessary imports as ``lazy``. In addition,
developers can mark imports that will only be used for type annotations as ``lazy``.

Below is guidance on how to best take advantage of lazy imports and how to avoid
incompatibilities: 

* When adopting lazy imports, users should be aware that eliding an import until it is 
  used will result in side effects not being executed. In turn, users should be wary of
  modules that rely on import time side effects. Perhaps the most common reliance on
  import side effects is the registry pattern, where population of some external
  registry happens implicitly during the importing of modules, often via
  decorators but sometimes implemented via metaclasses or ``__init_subclass__``.
  Instead, registries of objects should be constructed via explicit discovery
  processes (e.g. a well-known function to call).

* Always import needed submodules explicitly. It is not enough to rely on a different import
  to ensure a module has its submodules as attributes. Plainly, unless there is an
  explicit ``from . import bar`` in ``foo/__init__.py``, always use ``import
  foo.bar; foo.bar.Baz``, not ``import foo; foo.bar.Baz``. The latter only works
  (unreliably) because the attribute ``foo.bar`` is added as a side effect of
  ``foo.bar`` being imported somewhere else.

* Users who are moving imports into functions to improve startup time, should instead
  consider keeping them where they are but adding the ``lazy`` keyword. This allows
  them to keep dependencies clear and avoid the overhead of repeatedly re-resolving
  the import but will still speed up the program.

* Avoid using star imports, as those are always eager.

FAQ
===

**Q: How does this differ from the rejected PEP 690?**

A: PEP 805 takes an explicit, opt-in approach instead of PEP 690's implicit global approach. The key differences are:

- **Explicit syntax**: ``lazy import foo`` clearly marks which imports are lazy
- **Local scope**: Laziness only affects the specific import statement, not cascading to dependencies
- **Simpler implementation**: Uses proxy objects instead of modifying core dictionary behavior

**Q: What happens when lazy imports encounter errors?**

A: Import errors (``ImportError``, ``ModuleNotFoundError``, syntax errors) are
deferred until first use of the lazy name. This is similar to moving an import
into a function. The error will occur with a clear traceback pointing to the
first access of the lazy object.

**Q: How do lazy imports affect modules with import-time side effects?**

A: Side effects are deferred until first use. This is generally desirable for performance, but may require code changes for modules that rely on import-time registration patterns. We recommend:

- Use explicit initialization functions instead of import-time side effects
- Call initialization functions explicitly when needed
- Avoid relying on import order for side effects

**Q: Can I use lazy imports with** ``from ... import ...`` **statements?**

A: Yes as long as you don't use ``from ... import *``. Both ``lazy import foo``
and ``lazy from foo import bar`` are supported. The ``bar`` name will be bound
to a lazy object that resolves to ``foo.bar`` on first use.

**Q: What about type annotations and** ``TYPE_CHECKING`` **imports?**

A: Lazy imports eliminate the need for ``TYPE_CHECKING`` guards. You can write:

.. code-block:: python

  lazy from collections.abc import Sequence, Mapping  # No runtime cost

Instead of:

.. code-block:: python

  from typing import TYPE_CHECKING
  if TYPE_CHECKING:
      from collections.abc import Sequence, Mapping

**Q: What's the performance overhead of lazy imports?**

A: The overhead is minimal:

- Zero overhead after first use thanks to the adaptive interpreter optimizing the slow path away.
- Small one-time cost to create the proxy object.
- Reification (first use) has the same cost as a regular import.
- No ongoing performance penalty unlike ``importlib.util.LazyLoader``.

**Q: Can I mix lazy and eager imports of the same module?**

A: Yes. If module ``foo`` is imported both lazily and eagerly in the same
program, the eager import takes precedence and both bindings resolve to the same
module object.

**Q: How do I migrate existing code to use lazy imports?**

A: Migration is incremental:

1. Identify slow-loading modules using profiling tools
2. Add ``lazy`` keyword to imports that aren't needed immediately
3. Test that side-effect timing changes don't break functionality
4. Use ``__lazy_modules__`` for compatibility with older Python versions

**Q: What about star imports** (``from module import *``)?

A: Star imports cannot be lazy - they remain eager. This is because the set of
names being imported cannot be determined without loading the module. Using the
``lazy`` keyword with star imports will be a syntax error.

**Q: How do lazy imports interact with import hooks and custom loaders?**

A: Import hooks and loaders work normally. When a lazy object is first used, the
standard import protocol runs, including any custom hooks or loaders that were
in place at reification time.

**Q: What happens in multi-threaded environments?**

A: Lazy import reification is thread-safe. Only one thread will perform the
actual import, and the binding is atomically updated. Other threads will see
either the lazy proxy or the final resolved object.

**Q: Can I force reification of a lazy import without using it?**

A: Yes, accessing a module's ``__dict__`` will reify all lazy objects in that
module. Individual lazy objects can be resolved by calling their ``get()`` method.

**Q: Why not use** ``importlib.util.LazyLoader`` **instead?**

A: ``LazyLoader`` has significant limitations:

- Requires verbose setup code for each lazy import
- Has ongoing performance overhead on every attribute access
- Doesn't work well with ``from ... import`` statements
- Less clear and standard than dedicated syntax

**Q: Will this break tools like** ``isort`` **or** ``black``?

A: Tools will need updates to recognize the ``lazy`` keyword, but the changes
should be minimal since the import structure remains the same. The keyword
appears at the beginning, making it easy to parse.

**Q: How do I know if a library is compatible with lazy imports?**

A: Most libraries should work fine with lazy imports. Libraries that might have issues:

- Those with essential import-time side effects (registration, monkey-patching)
- Those that expect specific import ordering
- Those that modify global state during import

When in doubt, test lazy imports with your specific use cases.

**Q: Can I use lazy imports inside functions?**

A: No, the ``lazy`` keyword is only allowed at module level. For function-level
lazy loading, use traditional inline imports or move the import to module level
with ``lazy``.

**Q: What about forwards compatibility with older Python versions?**

A: Use the ``__lazy_modules__`` global for compatibility:

.. code-block:: python

  # Works on Python 3.15+ as lazy, eager on older versions
  __lazy_modules__ = ['expensive_module', 'expensive_module_2']
  import expensive_module
  from expensive_module_2 import MyClass

This provides a migration path until you can rely on the ``lazy`` keyword. For
maximum predictability, it's recommended to define ``__lazy_modules__`` once,
before any imports. But as it is checked on each import, it can be modified between
``import`` statements

**Q: How do explicit lazy imports interact with PEP-649/PEP-749**

A: If an annotation is not stringified, then it is a reference to the type, but it
will only be resolved if the annotation is accessed. In the example below, the ``fake_typing`` module 
is only loaded when the user inspects the ``__annotations__`` dictionary. The ``fake_typing``
module would also be loaded if the user had leveraged ``inspect.get_annotations()`` or ``getattr`` to access
the annotations. 

.. code-block:: python

  lazy from fake_typing import MyFakeType
  def foo(x: MyFakeType):
    pass
  print(foo.__annotations__)  # Triggers loading the fake_typing module
  
Reference Implementation
========================

[Link to any existing implementation and details about its state, e.g. proof-of-concept.]

Alternate Implementation
========================

Leveraging a Subclass of Dict
-----------------------------

Instead of updating the internal dict object to directly add the fields needed to support lazy imports, 
we could create a subclass of the dict object to be used specifically for Lazy Import enablement. This
would still be a leaky abstraction though - methods can be called directly such as ``dict.__getitem__``
and it would impact the performance of globals lookup in the interpreter.

Alternate Keyword Names
-----------------------

For this PEP, we decided to propose ``lazy`` for the explicit keyword as it felt the most familar to those
already focused on optimizing import overhead. We also considered a variety of other 
options to support explicit lazy imports. The most compelling alternates were ``defer`` and ``delay``.


Rejected Ideas
==============

Modification of the Dict Object
-------------------------------

The initial PEP for lazy imports (PEP 690) relied heavily on the modification of the internal dict 
object to support lazy imports. We recognize that this data structure is highly tuned, heavily used 
across the codebase, and very performance sensitive. Because of the importance of this data structure 
and the desire to keep the implementation of lazy imports encapsulated from users who may have no 
interest in the feature, we’ve decided to invest in an alternate approach.

Support of Import Cycles
------------------------

The initial PEP for lazy imports (PEP 690) contained support for eliminating most import cycles, 
but this meant that in some cases a codebase would no longer run successfully after disabling 
lazy imports. For the explicit lazy imports PEP we’ve decided not to add support for this use case. 
While codebases with heavily nested dependencies may benefit from this feature, supporting import 
cycles runs the risk of creating a dependency on lazy imports. As the intention of this PEP is to 
give users the power to opt in or opt out of lazy imports based on the specific needs within their 
codebases, we’ve decided not to implement this feature and instead prioritize backwards compatibility. 

Placing the ``lazy`` Keyword in the Middle of From Imports
----------------------------------------------------------

While we found, ``from foo lazy import bar`` to be a really intuitive placement for the new explicit syntax,
we quickly learned that placing the ``lazy`` keyword here is already syntactically allowed in Python. This
is because ``from foo. lazy import bar`` is legal syntax.

Placing the ``lazy`` Keyword at the End of Import Statements
------------------------------------------------------------

We discussed appending lazy to the end of import statements like such ``import foo lazy`` or 
``from foo import bar, baz lazy`` but ultimately decided that this approach provided less clarity. 
For example, if multiple modules are imported in a single statement, it is unclear if the lazy binding 
applies to all of the imported objects or just a subset of the items. 

Reifying lazy imports with ``globals()`` is called.
---------------------------------------------------
While ``globals()`` is also a common way to access variables which may contain lazy imports we will
not reify the lazy imports when it is called. There are a couple of problems with doing this. One
reason is that it is impossible to safely do this on-demand: we cannot return a proxy object as this
will break other usages of globals (e.g. passing them back to ``exec``).

Therefore it would require reifying all of the objects on the access and this behavior may be
surprising. There may also be a performance cost as it is impractical to cache whether this scan has
been done with just the globals dictionary in hand (versus when accessing from the module where we
can cache the results in the module).

Open Issues
===========

[Any points that are still being decided/discussed.]


Acknowledgements
================

[Thank anyone who has helped with the PEP.]


Footnotes
=========

.. [#f1] Furthermore, there's also external tooling, in the form of
   `flake8-type-checking <https://pypi.org/project/flake8-type-checking/>`_, because it is
   common for developers to mislocate imports and accidentally introduce a runtime
   dependency on an import only imported in such a block. Ironically, the static type
   checker is of no help in these circumstances.


Copyright
=========

This document is placed in the public domain or under the
CC0-1.0-Universal license, whichever is more permissive.
