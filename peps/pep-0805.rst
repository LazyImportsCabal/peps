PEP: 805
Title: Explicit lazy imports
Author: Pablo Galindo <pablogsal@python.org>,
        Germán Méndez Bravo <german.mb@gmail.com>,
        Thomas Wouters <thomas@python.org>,
        Dino Viehland <dinoviehland@gmail.com>,
        Brittany Reynoso <breynoso@meta.com>,
        Noah Kim <noahbkim@gmail.com>,
        Tim Stumbaugh <me@tjstum.com>
Discussions-To: Pending
Status: Draft
Type: Standards Track
Topic: Release
Created: 22-09-2025
Python-Version: 3.15


Abstract
========

This PEP introduces lazy imports as an explicit language feature. Lazy imports
defer the loading and execution of a module until the first time the imported
name is used, rather than at the point of the import statement.

By allowing developers to mark imports as lazy with new syntax, Python programs
can reduce startup time, memory usage, and unnecessary work. This is
particularly beneficial for command-line tools, test suites, and applications
with large dependency graphs.

The proposal preserves full backwards compatibility: normal import statements
remain unchanged, and lazy imports are enabled only where explicitly requested.

Motivation
==========

By convention, Python places imports at module level to avoid repetition and
extra overhead. The drawback is that importing a main module often triggers a
cascade of imports, loading many dependencies that may never be used. The effect
is especially costly for command-line tools with multiple subcommands, where
even a simple ``--help`` can load dozens of unnecessary modules.  This is
particularly bad for big CLIs that grew organically.

Some projects try to delay imports by moving them into functions, but this is
fragile and hard to maintain. Existing tools such as
``importlib.util.LazyLoader`` or third-party packages provide partial solutions
but either fail to cover all cases or add runtime overhead. Scientific Python
libraries have adopted similar patterns, formalized in `SPEC 1
<https://scientific-python.org/specs/spec-0001/>`_ and the ``lazy_loader``
package, and typing imports are another common case where eager loading is
wasteful.  

This proposal introduces lazy imports with a design that is local, explicit,
controlled, and granular. Each of these qualities is essential to making the
feature predictable and safe to use in practice.

The behavior is **local**: laziness applies only to the specific import marked
with the ``lazy`` keyword, and it does not cascade recursively into other
imports. This ensures that developers can reason about the effect of laziness
by looking only at the line of code in front of them, without worrying about
whether imported modules will themselves behave differently. A ``lazy import``
is an isolated decision, not a global shift in semantics.

The semantics are also **explicit**. When a name is imported lazily, the binding
is created in the importing module immediately, but the target module is not
loaded until the first time the name is accessed. After this point, the binding
is indistinguishable from a normal import. This clarity reduces surprises and
makes the feature accessible to developers who may not be deeply familiar with
Python’s import machinery.

Lazy imports are **controlled**, in the sense that deferred loading is only
triggered by the importing code itself. In the general case, a library will only
experience lazy imports if its own authors choose to mark them as such. This
avoids shifting responsibility onto downstream users and prevents accidental
surprises in library behavior. Since library authors typically manage their own
import subgraphs, they retain predictable control over when and how laziness is
applied.

The mechanism is also **granular**. It is introduced through explicit syntax on
individual imports, rather than a global flag or implicit setting. This allows
developers to adopt it incrementally, starting with the most
performance-sensitive areas of a codebase. The experience is similar to the way
typing was introduced into Python: optional, progressive, and adaptable to the
needs of each project.

The design of lazy imports provides several concrete advantages:

* Startup latency is critical for command-line tools, many of which are
  short-lived processes. A CLI with multiple subcommands typically imports
  every dependency up front, even if the user only requests ``tool --help``.
  With lazy imports, only the code paths actually reached trigger module
  loading. This can reduce startup time by 50–70% in practice, restoring
  Python's competitiveness in domains where fast startup matters most.

* Type annotations frequently require imports that are never used at runtime.
  The common workaround is to wrap them in ``if TYPE_CHECKING:`` blocks, which
  adds boilerplate and complexity. With lazy imports, annotation-only imports
  impose no runtime penalty, eliminating the need for guards and making
  annotated codebases cleaner.

* Large applications often import thousands of modules, each adding objects and
  state to memory. In long-lived processes this raises baseline memory usage
  and reduces stability under load. Lazy imports defer this cost until a module
  is needed, keeping unused subsystems unloaded. Memory savings of 30–40% have
  been observed in real workloads.

Rationale
=========

The design of this proposal is centered on clarity, predictability, and ease of
adoption. Each decision was made to ensure that lazy imports provide tangible
benefits without introducing unnecessary complexity into the language or its
runtime.

It is also worth noting that while this PEP outlines one specific approach, we
list alternate implementation strategies for some of the core aspects and
semantics of the proposal. If the community expresses a strong preference for a
different technical path that still preserves the same core semantics or there
is fundamental disagreement over the specific option, the Steering Council can
easily choose to accept the proposal with what they think is the best set of
options for the language.

The choice to introduce a new ``lazy`` keyword reflects the need for explicit
syntax. Import behavior is too fundamental to be left implicit or hidden behind
global flags or environment variables. By marking laziness directly at the
import site, the intent is immediately visible to both readers and tools. This
avoids surprises, reduces the cognitive burden of reasoning about imports, and
keeps the semantics in line with Python's tradition of explicitness.

Another important decision is to represent lazy imports with proxy objects in
the module's namespace, rather than by modifying dictionary lookup. Earlier
approaches experimented with embedding laziness into dictionaries, but this
blurred abstractions and risked affecting unrelated parts of the runtime. The
proxy approach is simpler: it behaves like a placeholder until first use, at
which point it resolves the import and rebinds the name. From then on, the
binding is indistinguishable from a normal import. This makes the mechanism
easy to explain and keeps the rest of the interpreter unchanged.

Compatibility for library authors was also a key concern. Many maintainers need
a migration path that allows them to support both new and old versions of
Python at once. For this reason, the proposal includes the ``__lazy_modules__``
global as a transitional mechanism. A module can declare which imports should
be treated as lazy, and on Python 3.15 or later those imports will become lazy
automatically. On earlier versions the declaration is ignored, leaving imports
eager. This gives authors a practical bridge until they can rely on the keyword
as the canonical syntax.

Finally, the feature is designed to be adopted incrementally. Nothing changes
unless a developer explicitly opts in, and adoption can begin with just a few
imports in performance-sensitive areas. This mirrors the experience of gradual
typing in Python: a mechanism that can be introduced progressively, without
forcing projects to commit globally from day one. By combining explicit syntax,
a simple runtime model, a compatibility layer, and gradual adoption, this
proposal balances performance improvements with the clarity and stability that
Python users expect.


Other design decisions
----------------------

* The scope of laziness is deliberately local and non-recursive. A lazy import
  only affects the specific statement where it appears; it does not cascade into
  other modules or submodules. This choice is crucial for predictability. When
  developers read code, they can reason about import behavior line by line,
  without worrying about hidden laziness deeper in the dependency graph. The
  result is a feature that is powerful but still easy to understand in context.

* In addition, it is useful to provide a mechanism to activate or deactivate lazy
  imports at a global level. While the primary design centers on explicit syntax,
  there are scenarios—such as large applications, testing environments, or
  frameworks—where enabling laziness consistently across many modules provides
  the most benefit. A global switch makes it easy to experiment with or enforce
  consistent behavior, while still working in combination with the filtering API
  to respect exclusions or tool-specific configuration. This ensures that global
  adoption can be practical without reducing flexibility or control.


Specification
=============

[Describe the syntax and semantics of any new language feature.]


Backwards Compatibility
=======================

[Describe potential impact and severity on pre-existing code.]


Security Implications
=====================

[How could a malicious user take advantage of this new feature?]


How to Teach This
=================

[How to teach users, new and experienced, how to apply the PEP to their work.]

FAQ
===

[A list of frequently asked questions with answers]

Reference Implementation
========================

[Link to any existing implementation and details about its state, e.g. proof-of-concept.]


Rejected Ideas
==============

[Why certain ideas that were brought while discussing this PEP were not ultimately pursued.]


Open Issues
===========

[Any points that are still being decided/discussed.]


Acknowledgements
================

[Thank anyone who has helped with the PEP.]


Footnotes
=========

[A collection of footnotes cited in the PEP, and a place to list non-inline hyperlink targets.]


Copyright
=========

This document is placed in the public domain or under the
CC0-1.0-Universal license, whichever is more permissive.
