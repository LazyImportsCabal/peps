PEP: 805
Title: Explicit lazy imports
Author: Pablo Galindo <pablogsal@python.org>,
        Germán Méndez Bravo <german.mb@gmail.com>,
        Thomas Wouters <thomas@python.org>,
        Dino Viehland <dinoviehland@gmail.com>,
        Brittany Reynoso <breynoso@meta.com>,
        Noah Kim <noahbkim@gmail.com>,
        Tim Stumbaugh <me@tjstum.com>
Discussions-To: Pending
Status: Draft
Type: Standards Track
Topic: Release
Created: 22-09-2025
Python-Version: 3.15


Abstract
========

This PEP introduces lazy imports as an explicit language feature. Lazy imports
defer the loading and execution of a module until the first time the imported
name is used, rather than at the point of the import statement.

By allowing developers to mark imports as lazy with new syntax, Python programs
can reduce startup time, memory usage, and unnecessary work. This is
particularly beneficial for command-line tools, test suites, and applications
with large dependency graphs.

The proposal preserves full backwards compatibility: normal import statements
remain unchanged, and lazy imports are enabled only where explicitly requested.

Motivation
==========

By convention, Python places imports at module level to avoid repetition and
extra overhead. The drawback is that importing a main module often triggers a
cascade of imports, loading many dependencies that may never be used. The effect
is especially costly for command-line tools with multiple subcommands, where
even a simple ``--help`` can load dozens of unnecessary modules.  This is
particularly bad for big CLIs that grew organically.

Some projects try to delay imports by moving them into functions, but this practice 
is fragile, hard to maintain, and obfuscates the full set of dependencies of a module. 
Existing tools such as ``importlib.util.LazyLoader`` and existing third-party packages provide 
partial solutions but either fail to cover all cases or add runtime overhead. Scientific 
Python libraries have adopted similar patterns, formalized in `SPEC 1
<https://scientific-python.org/specs/spec-0001/>`_ and the ``lazy_loader``
package. In addition, typing imports are another common case where unneeded imports are 
wastefully eagerly loaded.

This proposal introduces lazy imports with a design that is local, explicit,
controlled, and granular. Each of these qualities is essential to making the
feature predictable and safe to use in practice.

The behavior is **local**: laziness applies only to the specific import marked
with the ``lazy`` keyword, and it does not cascade recursively into other
imports. This ensures that developers can reason about the effect of laziness
by looking only at the line of code in front of them, without worrying about
whether imported modules will themselves behave differently. A ``lazy import``
is an isolated decision, not a global shift in semantics.

The semantics are also **explicit**. When a name is imported lazily, the binding
is created in the importing module immediately, but the target module is not
loaded until the first time the name is accessed. After this point, the binding
is indistinguishable from a normal import. This clarity reduces surprises and
makes the feature accessible to developers who may not be deeply familiar with
Python’s import machinery.

Lazy imports are **controlled**, in the sense that deferred loading is only
triggered by the importing code itself. In the general case, a library will only
experience lazy imports if its own authors choose to mark them as such. This
avoids shifting responsibility onto downstream users and prevents accidental
surprises in library behavior. Since library authors typically manage their own
import subgraphs, they retain predictable control over when and how laziness is
applied.

The mechanism is also **granular**. It is introduced through explicit syntax on
individual imports, rather than a global flag or implicit setting. This allows
developers to adopt it incrementally, starting with the most
performance-sensitive areas of a codebase. The experience is similar to the way
typing was introduced into Python: optional, progressive, and adaptable to the
needs of each project.

The design of lazy imports provides several concrete advantages:

* Startup latency is critical for command-line tools, many of which are
  short-lived processes. A CLI with multiple subcommands typically imports
  every dependency up front, even if the user only requests ``tool --help``.
  With lazy imports, only the code paths actually reached trigger module
  loading. This can reduce startup time by 50–70% in practice, restoring
  Python's competitiveness in domains where fast startup matters most.

* Type annotations frequently require imports that are never used at runtime.
  The common workaround is to wrap them in ``if TYPE_CHECKING:`` blocks, which
  adds boilerplate and complexity. With lazy imports, annotation-only imports
  impose no runtime penalty, eliminating the need for guards and making
  annotated codebases cleaner.

* Large applications often import thousands of modules, each adding objects and
  state to memory. In long-lived processes this raises baseline memory usage
  and reduces stability under load. Lazy imports defer this cost until a module
  is needed, keeping unused subsystems unloaded. Memory savings of 30–40% have
  been observed in real workloads.

Rationale
=========

The design of this proposal is centered on clarity, predictability, and ease of
adoption. Each decision was made to ensure that lazy imports provide tangible
benefits without introducing unnecessary complexity into the language or its
runtime.

It is also worth noting that while this PEP outlines one specific approach, we
list alternate implementation strategies for some of the core aspects and
semantics of the proposal. If the community expresses a strong preference for a
different technical path that still preserves the same core semantics or there
is fundamental disagreement over the specific option, the Steering Council can
easily choose to accept the proposal with what they think is the best set of
options for the language.

The choice to introduce a new ``lazy`` keyword reflects the need for explicit
syntax. Import behavior is too fundamental to be left implicit or hidden behind
global flags or environment variables. By marking laziness directly at the
import site, the intent is immediately visible to both readers and tools. This
avoids surprises, reduces the cognitive burden of reasoning about imports, and
keeps the semantics in line with Python's tradition of explicitness.

Another important decision is to represent lazy imports with proxy objects in
the module's namespace, rather than by modifying dictionary lookup. Earlier
approaches experimented with embedding laziness into dictionaries, but this
blurred abstractions and risked affecting unrelated parts of the runtime. The
proxy approach is simpler: it behaves like a placeholder until first use, at
which point it resolves the import and rebinds the name. From then on, the
binding is indistinguishable from a normal import. This makes the mechanism
easy to explain and keeps the rest of the interpreter unchanged.

Compatibility for library authors was also a key concern. Many maintainers need
a migration path that allows them to support both new and old versions of
Python at once. For this reason, the proposal includes the ``__lazy_modules__``
global as a transitional mechanism. A module can declare which imports should
be treated as lazy, and on Python 3.15 or later those imports will become lazy
automatically. On earlier versions the declaration is ignored, leaving imports
eager. This gives authors a practical bridge until they can rely on the keyword
as the canonical syntax.

Finally, the feature is designed to be adopted incrementally. Nothing changes
unless a developer explicitly opts in, and adoption can begin with just a few
imports in performance-sensitive areas. This mirrors the experience of gradual
typing in Python: a mechanism that can be introduced progressively, without
forcing projects to commit globally from day one. By combining explicit syntax,
a simple runtime model, a compatibility layer, and gradual adoption, this
proposal balances performance improvements with the clarity and stability that
Python users expect.


Other design decisions
----------------------

* The scope of laziness is deliberately local and non-recursive. A lazy import
  only affects the specific statement where it appears; it does not cascade into
  other modules or submodules. This choice is crucial for predictability. When
  developers read code, they can reason about import behavior line by line,
  without worrying about hidden laziness deeper in the dependency graph. The
  result is a feature that is powerful but still easy to understand in context.

* In addition, it is useful to provide a mechanism to activate or deactivate lazy
  imports at a global level. While the primary design centers on explicit syntax,
  there are scenarios—such as large applications, testing environments, or
  frameworks—where enabling laziness consistently across many modules provides
  the most benefit. A global switch makes it easy to experiment with or enforce
  consistent behavior, while still working in combination with the filtering API
  to respect exclusions or tool-specific configuration. This ensures that global
  adoption can be practical without reducing flexibility or control.


Specification
=============

A new soft keyword is added, ``lazy`` (other names have been suggested), which
can appear in front of both forms of import:

* ``lazy import spam``

* ``lazy from spam import ham``

The soft keyword is only allowed at the global level, so not inside
functions. It's also not allowed in try blocks. Import statements that use
the soft keyword are potentially lazy.

If the importing module has a ``__lazy_modules__`` attribute, it contains a
list of names the imports of which are potentially lazy (as if the lazy
keyword was used).

The normal (non-lazy) import statement also checks the global lazy imports
flag. If it is ``"enabled"``, all imports at the global level that are not in
a try block are potentially lazy.

If the global lazy imports flag is set to ``"disabled"``, the import is _not_
lazy (as if the lazy keyword was not used).

For potentially lazy imports, the lazy imports filter (if set) is called,
passing the name of the module doing the import, the module being imported,
and (if applicable) the fromlist. If the lazy import filter returns True the
lazy import continues. Otherwise, the import is _not_ lazy, and the normal
import continues.

When an import is lazy, ``__lazy_import__`` is called instead of ``__import__``.
``__lazy_import__`` will:

* Check if the module already exists in ``sys.modules``, and return that if it is.

* Add the module to ``sys.lazy_modules``, a set of modules which have been lazily imported.

* Return a "lazy module object".

The implementation of ``from ... import`` (the ``IMPORT_FROM`` bytecode
implementation) checks if the module it's fetching from is a lazy module
object, and if so, returns lazy objects for each name instead.

The end result of this process is that lazy imports (regardless of how they
are enabled) result in lazy objects being assigned to global variables.

Lazy module objects do not appear in ``sys.modules``, just the
``sys.lazy_modules`` set. Lazy objects should only end up stored in global
variables, and the common ways to access those variables (regular variable
access, module attributes, ``globals()``) will resolve lazy imports ("reify")
and replace them when they're accessed.

It is still possible to expose lazy objects through other means, like
debuggers. This is not considered a problem.

Reification
-----------

When a lazy object is first used, it needs to be reified. This means
resolving the import at that point in the program, and replacing the lazy
object with the concrete one. Reification imports the module the same as it
would have been if it had been imported eagerly, barring changes to the
import system (like changes to ``sys.path``, ``sys.meta_path``, ``sys.path_hooks``
or ``__import__``).

Reification calls ``__import__`` to resolve the import. Once the module is
reified it's removed from ``sys.lazy_modules``.

Reification does _not_ automatically occur when a module that was lazily
imported before is eagerly imported. Reification does _not_ resolve all lazy
objects referencing the module. It only resolves the lazy object being
accessed.

Accessing a lazy object (from a global variable or a module attribute)
reifies the object. Accessing a module's ``__dict__`` or calling ``globals()``
(and ``locals()`` at the global level, where it means the same as ``globals()``)
reifies _all_ lazy objects in that module.

More indirect ways of accessing arbitrary globals (e.g. inspecting
``frame.f_globals``) does _not_ reify all the objects. A lazy object can be
resolved explicitly by calling the ``get`` method.


Backwards Compatibility
=======================

[Describe potential impact and severity on pre-existing code.]


Security Implications
=====================

[How could a malicious user take advantage of this new feature?]


How to Teach This
=================

[How to teach users, new and experienced, how to apply the PEP to their work.]

FAQ
===

[A list of frequently asked questions with answers]

Reference Implementation
========================

[Link to any existing implementation and details about its state, e.g. proof-of-concept.]

Alternate Implementation
========================

Leveraging a Subclass of Dict
-----------------------------

Instead of updating the internal dict object to directly add the fields needed to support lazy imports, 
we could create a subclass of the dict object to be used specifically for Lazy Import enablement. 

Alternate Keyword Names
-----------------------

We also considered a variety of other keywords to support explicit lazy imports. The most compelling 
alternate options were ``defer`` and ``delay``.


Rejected Ideas
==============

Modification of the Dict Object
-------------------------------

The initial PEP for lazy imports (PEP 690) relied heavily on the modification of the internal dict 
object to support lazy imports. We recognize that this data structure is highly tuned, heavily used 
across the codebase, and very performance sensitive. Because of the importance of this data structure 
and the desire to keep the implementation of lazy imports encapsulated from users who may have no 
interest in the feature, we’ve decided to invest in an alternate approach.

Support of Import Cycles
------------------------

The initial PEP for lazy imports (PEP 690) contained support for eliminating most import cycles, 
but this meant that in some cases a codebase would no longer run successfully after disabling 
lazy imports. For the explicit lazy imports PEP we’ve decided not to add support for this use case. 
While codebases with heavily nested dependencies may benefit from this feature, supporting import 
cycles runs the risk of creating a dependency on lazy imports. As the intention of this PEP is to 
give users the power to opt in or opt out of lazy imports based on the specific needs within their 
codebases, we’ve decided not to implement this feature and instead prioritize backwards compatibility. 

Placing the ``lazy`` Keyword at the End of Import Statements
------------------------------------------------------------

We discussed appending lazy to the end of import statements like such ``import foo lazy`` or 
``from foo import bar, baz lazy`` but ultimately decided that this approach provided less clarity. 
For example, if multiple modules are imported in a single statement, it is unclear if the lazy binding 
applies to all of the imported objects or just a subset of the items. 

Open Issues
===========

[Any points that are still being decided/discussed.]


Acknowledgements
================

[Thank anyone who has helped with the PEP.]


Footnotes
=========

[A collection of footnotes cited in the PEP, and a place to list non-inline hyperlink targets.]


Copyright
=========

This document is placed in the public domain or under the
CC0-1.0-Universal license, whichever is more permissive.
